----------------------------------------------------------------------------------------------------------------------
-- xr_corpse_detection
-- Alundaio (original: Stohe)
----------------------------------------------------------------------------------------------------------------------
local ini = ini_file("ai_tweaks\\xr_corpse_detection.ltx")
local DeathTimeDanger = alun_utils.read_from_ini(ini,"settings","death_time_danger","string","60000")
local AlwaysDetectDistanceFree = alun_utils.read_from_ini(ini,"settings","always_detect_dist_free","float",2500)
local AlwaysDetectDistanceDanger = alun_utils.read_from_ini(ini,"settings","always_detect_dist_danger","float",125)
local StateWalk	 = alun_utils.read_from_ini(ini,"settings","state_walk","string","walk_noweap")
local StateRun	 = alun_utils.read_from_ini(ini,"settings","state_run","string","rush")
local MonsterLoot = alun_utils.read_from_ini(ini,"settings","enable_mutant_looting","bool",false)
local MonsterLootCommunities = alun_utils.collect_section(ini,"loot_mutant_communities",true)
lootable_table = alun_utils.collect_section(ini,"lootable",true)
ini = nil

function on_game_start()
	callback_register("npc_on_item_take",on_item_take)
	callback_register("npc_on_item_drop",on_item_drop)
	callback_register("npc_on_death_callback",on_death_callback)
	callback_register("monster_on_death_callback",monster_on_death_callback)
	callback_register("monster_on_net_spawn",monster_on_net_spawn)
end

local HasValuableLoot = {}
function on_item_take(npc,item)
	if (npc:alive()) then
		return
	end
	if (lootable_table[item:section()]) then
		HasValuableLoot[npc:id()] = true
		return
	end
end

function on_item_drop(npc,item)
	if (not npc or npc:alive()) then
		return
	end
	local se_item = alife():object(item:id())
	if (se_item and se_item.parent_id == db.actor:id()) then
		local corpse_contain_any_valuable
		HasValuableLoot[npc:id()] = nil
		local function check_item(npc,item)
			if (lootable_table[item:section()]) then
				corpse_contain_any_valuable = true
			end
		end

		npc:iterate_inventory(check_item,npc)

		if (corpse_contain_any_valuable) then
			HasValuableLoot[npc:id()] = true
		end
	end
end

function on_death_callback(npc,who)
	local corpse_contain_any_valuable
	HasValuableLoot[npc:id()] = nil
	local function check_item(npc,item)
		if (lootable_table[item:section()]) then
			corpse_contain_any_valuable = true
		end
	end

	npc:iterate_inventory(check_item,npc)

	if (corpse_contain_any_valuable) then
		HasValuableLoot[npc:id()] = true
	end

	alun_utils.save_var(npc,"death_by_id",who:id())
	if (who:id() == db.actor:id()) then
		local itm = db.actor:active_item()
		if (itm and itm:clsid() == clsid.wpn_knife_s) then
			alun_utils.save_var(npc,"death_by_knife",true)
		end
	end
end

function monster_on_death_callback(obj,who)
	if not (MonsterLoot) then
		return
	end
	HasValuableLoot[obj:id()] = true
end

function monster_on_net_spawn(obj)
	if not (MonsterLoot) then
		return
	end

	if (obj:alive()) then
		return
	end

	local se_obj = alife():object(obj:id())
	HasValuableLoot[obj:id()] = se_obj and not se_obj.looted
end

function has_valuable_loot(obj)
	return HasValuableLoot[obj:id()] == true
end

function set_valuable_loot(id,val)
	HasValuableLoot[id] = val
end
----------------------------------------------------------------------------------------------------------------------
-- EVALUATORS
----------------------------------------------------------------------------------------------------------------------
class "evaluator_corpse" (property_evaluator)
function evaluator_corpse:__init(name, storage, npc) super (nil, name)
	self.a = storage
	self.a.dtimer = 0
	self.a.stage = 1
end
function evaluator_corpse:evaluate()
	if (surge_manager.is_started() == true) then
		return false
	end

	local enabled = xr_logic.pick_section_from_condlist(db.actor, self.object, self.a.corpse_detection_enabled)
	if (enabled ~= "true") then
		return false
	end

	local npc = self.object
	if not npc:alive() or npc:best_enemy() or xr_wounded.is_wounded(npc) then
		return false
	end

	if (alun_utils.get_squad_commander_action(npc) == stalker_ids.action_combat_planner) then
		return false
	end

	return this["eval_stage_"..self.a.stage](self.a,npc)
end

function eval_stage_1(st,npc)
	local tg = time_global()
	if st.dtimer > tg then
		return false
	end
	st.dtimer = tg+3500

	local corpses = release_body_manager.get_release_body_manager().release_objects_table
	local nearest_corpse_dist
	local nearest_corpse_vertex
	local nearest_corpse_position
	local corpse_id
	local corpse_pos
	local dist
	local corpse_vertex
	local id
	local corpse_npc
	local detect_dist
	local dt_threshold
	local inertion

	local se_npc = alife():object(npc:id())
	if not (se_npc) then
		alun_utils.printf("xr_corpse_detection: se_npc = nil! npc = %s",npc and npc:name())
		return
	end
	local squad = se_npc.group_id ~= 65535 and alife():object(se_npc.group_id)
	local can_loot_mutants = squad and squad.player_id and MonsterLootCommunities[squad.player_id] or MonsterLootCommunities[character_community(npc)]

	local size = #corpses
	for i=1,size do
		id = corpses[i].id
		corpse_npc = db.storage[id] and db.storage[id].object or level.object_by_id(id)
		if corpse_npc and HasValuableLoot[id] and db.storage[id].corpse_already_selected == nil then
			if (IsStalker(corpse_npc) or can_loot_mutants) then
				corpse_pos = corpse_npc:bone_position("bip01_spine")
				dist = npc:position():distance_to_sqr(corpse_pos)

				if not (nearest_corpse_dist) then
					nearest_corpse_dist = dist
				end

				dt_threshold = npc:relation(corpse_npc) == game_object.friend and tg - corpse_npc:death_time()
				inertion = xr_logic.pick_section_from_condlist(db.actor,npc,xr_logic.parse_condlist(npc,"settings","death_time_danger",DeathTimeDanger))

				detect_dist = alun_utils.load_var(corpse_npc,"death_by_knife") and 0 or dt_threshold and dt_threshold > tonumber(inertion) and AlwaysDetectDistanceDanger or AlwaysDetectDistanceFree

				if (dist <= detect_dist) or (npc:see(corpse_npc) and dist < nearest_corpse_dist) then
					corpse_vertex = level.vertex_id(corpse_pos)
					if level.vertex_position(corpse_vertex):distance_to_sqr(corpse_pos) > 16 then
						corpse_vertex = corpse_npc:level_vertex_id()
					end
					if npc:accessible(corpse_vertex) and level.vertex_position(corpse_vertex):distance_to_sqr(corpse_pos) <= 15 then
						nearest_corpse_dist = dist
						nearest_corpse_vertex = corpse_vertex
						nearest_corpse_position = corpse_pos
						corpse_id = id
					end
				end
			end
		end
	end
	if nearest_corpse_vertex ~= nil then
		if (st.selected_corpse_id and db.storage[st.selected_corpse_id]) then
			db.storage[st.selected_corpse_id].corpse_already_selected = nil
		end
		st.vertex_id = nearest_corpse_vertex
		st.vertex_position = nearest_corpse_position
		st.selected_corpse_id = corpse_id
		st.stage = 2
		--alun_utils.printf("%s Found lootable Corpse",npc:name())
		return true
	end
end

function eval_stage_2(st,npc)
	local corpse = db.storage[st.selected_corpse_id] and db.storage[st.selected_corpse_id].object
	if corpse and HasValuableLoot[st.selected_corpse_id] and (db.storage[st.selected_corpse_id].corpse_already_selected == nil or db.storage[st.selected_corpse_id].corpse_already_selected == npc:id()) then
		if corpse:position():distance_to_sqr(st.vertex_position) > 15 then
			st.stage = 1
			return false
		end
		return true
	else
		st.stage = 1
		return false
	end
end
----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
class "action_search_corpse" (action_base)
function action_search_corpse:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_search_corpse:initialize()
	action_base.initialize(self)
	local npc = self.object
	npc:set_desired_position()
	npc:set_desired_direction()
	npc:set_path_type(game_object.level_path)
	npc:set_dest_level_vertex_id(self.a.vertex_id)

	local corpse = db.storage[self.a.selected_corpse_id] and db.storage[self.a.selected_corpse_id].object
	local dt_threshold = corpse and npc:relation(corpse) == game_object.friend and time_global() - corpse:death_time()

	local inertion = xr_logic.pick_section_from_condlist(db.actor,npc,xr_logic.parse_condlist(npc,"settings","death_time_danger",DeathTimeDanger))
	if (not dt_threshold or dt_threshold > tonumber(inertion)) then
		self.a.dist_run = math.random(5,30)
	else
		self.a.dist_run = 1
	end

	db.storage[self.a.selected_corpse_id].corpse_already_selected = npc:id()
end
function action_search_corpse:execute()
	action_base.execute(self)
	local npc = self.object

	local tg = time_global()
	if (self.a.timer and tg > self.a.timer) then
		--alun_utils.printf("%s Looting corpse due to hang time.",npc:name())
		get_all_from_corpse(npc)
		return
	end

	local dist = npc:position():distance_to(self.a.vertex_position)
	if (dist < self.a.dist_run) then
		state_mgr.set_state(self.object,"patrol")
	else
		state_mgr.set_state(self.object,"rush")
	end

	if (dist < 1.3 or npc:level_vertex_id() == self.a.vertex_id) then
		local corpse = db.storage[self.a.selected_corpse_id] and db.storage[self.a.selected_corpse_id].object
		local who = alun_utils.load_var(corpse,"death_by_id",nil)
		who = who and level.object_by_id(who)

		if (who and who:alive() and npc:relation(who) == game_object.enemy) then
			local dt_threshold = corpse and npc:relation(corpse) == game_object.friend and tg - corpse:death_time()
			local inertion = xr_logic.pick_section_from_condlist(db.actor,npc,xr_logic.parse_condlist(npc,"settings","death_time_danger",DeathTimeDanger))
			if (dt_threshold and dt_threshold < tonumber(inertion)) then
				if not (self.a.danger_timer) then
					self.a.danger_timer = tg + 5000
				end

				if (tg > self.a.danger_timer) then
					if (xr_danger.set_script_danger) then
						xr_danger.set_script_danger(npc,DeathTimeDanger-dt_threshold)
					end

					if not (self.say_search) then
						if (math.random() > 0.5) then
							xr_sound.set_sound_play(npc:id(),"search")
						end
						self.say_search = true
					end

					return
				end

				if (math.random() < 0.60 and ranks.get_obj_rank_name(npc) ~= "master") then
					state_mgr.set_state(npc,"search")
				end

				if not (self.say_tolls) then
					if (math.random() > 0.5) then
						xr_sound.set_sound_play(npc:id(),"tolls")
					end
					self.say_tolls = true
				end

				return
			end
		end

		if not (self.a.timer) then
			self.a.timer = tg + 12000
		end

		if not self.sound then
			if math.random() < 0.60 then
				xr_sound.set_sound_play(npc:id(),"corpse_loot_begin")
			end
			self.sound = true
		end

		look_pos = corpse and corpse:bone_position("bip01_spine") or self.a.vertex_position
		state_mgr.set_state(npc,"search_corpse",nil,nil,{look_position = look_pos})
	else
		if state_mgr.get_state(npc) == "search_corpse" then
			state_mgr.set_state(npc,"rush")
			npc:set_dest_level_vertex_id(self.a.vertex_id)
		end
	end
end
function action_search_corpse:finalize()
	action_base.finalize(self)
	if db.storage[self.a.selected_corpse_id] then
		db.storage[self.a.selected_corpse_id].corpse_already_selected = nil
	end
	self.a.selected_corpse_id = nil
	self.a.dist_run = nil
	self.sound = nil
	self.a.timer = nil

	self.object:set_item(object.strap,self.object:best_weapon()) -- fix freeze

--	state_mgr.set_state(self.object,"idle",nil,nil,nil,{fast_set = true})
end

function get_all_from_corpse(npc)
	local id = npc:id()
	db.storage[id].corpse_detection.active = nil
	db.storage[id].corpse_detection.dtimer = time_global()+500
	local corpse_npc_id = db.storage[id].corpse_detection.selected_corpse_id
	local corpse_npc = db.storage[corpse_npc_id] and db.storage[corpse_npc_id].object
	if corpse_npc == nil then
		return
	end

	HasValuableLoot[corpse_npc:id()] = nil

	if not(IsStalker(corpse_npc)) then
		local looted = alun_utils.load_var(corpse_npc,"looted",nil)
		if (not looted and itms_manager) then
			local loot = {}
			itms_manager.loot_mutant(nil,corpse_npc:clsid(),loot,npc)

			local is_there_loot
			for sec,t in pairs(loot) do
				is_there_loot = true
				break
			end

			if (is_there_loot) then
				xr_sound.set_sound_play(id,"corpse_loot_good")
			else
				xr_sound.set_sound_play(id,"corpse_loot_bad")
			end
			alun_utils.save_var(corpse_npc,"looted",true)
		end
		return
	end

	local items_value = 0
	local function get_item(corpse,item)
		if (lootable_table[item:section()]) then
			if (items_value < 100) then
				items_value = items_value+item:cost()*item:condition()/30
			end
			corpse:transfer_item(item,npc)
		end
	end

	corpse_npc:iterate_inventory(get_item,corpse_npc)

	if items_value >= 100 then
		xr_sound.set_sound_play(id,"corpse_loot_good")
	elseif items_value > 0 and math.random() < 0.5 then
		xr_sound.set_sound_play(id,"corpse_loot_bad")
	end

	if (axr_main) then
		axr_main.npc_on_get_all_from_corpse(npc,corpse_npc)
	end
end

----------------------------------------------------------------------------------------------------------------------
-- BINDER
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(npc, char_ini, scheme, section, st)
	local operators	= {}
	local properties  = {}


	properties["corpse_exist"]				= xr_evaluators_id.corpse_exist
	properties["wounded"]					= xr_evaluators_id.sidor_wounded_base

	operators["search_corpse"]				= xr_actions_id.corpse_exist
	operators["state_mgr_to_idle_alife"]	= xr_actions_id.state_mgr + 2

	local manager = npc:motivation_action_manager()


	if (character_community(npc) == "zombied" or npc:section() == "actor_visual_stalker") then
		manager:add_evaluator(properties["corpse_exist"],property_evaluator_const(false))
	end

	-- Evaluators
	manager:add_evaluator (properties["corpse_exist"], 		evaluator_corpse("corpse_exist", st))

	-- Actions
	local action = action_search_corpse (npc:name(),"action_search_corpse", st)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	action:add_precondition		(world_property(stalker_ids.property_danger,false))
	action:add_precondition		(world_property(stalker_ids.property_anomaly,false))
	action:add_precondition		(world_property(stalker_ids.property_items,false))
	action:add_precondition		(world_property(properties["corpse_exist"],	true))
	action:add_precondition		(world_property(properties["wounded"], 		false))
	action:add_precondition 	(world_property(xr_evaluators_id.wounded_exist,		false))
	action:add_effect (world_property(properties["corpse_exist"], 			false))
	manager:add_action (operators["search_corpse"], action)

	action = manager:action(xr_actions_id.alife)
	action:add_precondition(world_property(properties["corpse_exist"],false))

	action = manager:action(operators["state_mgr_to_idle_alife"])
	action:add_precondition(world_property(properties["corpse_exist"],false))
end

function set_corpse_detection(npc, ini, scheme, section)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
end


function reset_corpse_detection(npc, scheme, st, section)
	st.corpse_detection.corpse_detection_enabled = xr_logic.parse_condlist(npc, section, "corpse_detection_enabled",utils.cfg_get_string(st.ini, section, "corpse_detection_enabled", npc, false,"","true"))
end

function is_under_corpse_detection(npc)
	local mgr = npc:motivation_action_manager()

	if not mgr:initialized() then
		return false
	end

	local current_action_id = mgr:current_action_id()
	return  current_action_id == xr_actions_id.corpse_exist
end
