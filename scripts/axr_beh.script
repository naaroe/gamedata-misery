--[[
	axr_beh.script
	Behavior Manager
	Alundaio
--]]

function on_game_start()
	load_scheme("axr_beh","beh",0)
	callback_register("scheme_set",set_scheme)
end

local keep_state_min_time = 1000

--------------------------------Action Base Evaluator ---------------------------------------------------------------------

class "evaluator_beh" (property_evaluator)
function evaluator_beh:__init(storage, name) super (nil, name)
	self.st = storage
end

function evaluator_beh:evaluate()
	return xr_logic.is_active(self.object, self.st)
end

--------------------------------------Action Base --------------------------------------------------------------------------------
class "action_beh" (action_base)
function action_beh:__init(npc_name, action_name, storage) super (nil, action_name)
	self.st = storage
end

function action_beh:initialize()
	action_base.initialize(self)
	self.object:set_desired_position()
	self.object:set_desired_direction()
	--self.object:enable_talk()
	self.st.assist_point = nil
	state_mgr.set_state(self.object, "guard", nil, nil, nil, { animation = true })
	self.keep_state_until = time_global()
end

function action_beh:execute()
	action_base.execute(self)

	self:set_desired_distance()
	self:set_desired_behavior()
	self:set_desired_animation()

	if (self.st.behavior == "beh_move") then
		self:set_desired_target()
	end

	if (self.st.behavior and self.st.desired_target and next(self.st.desired_target)) then
		if (self.st.behavior == "beh_wait") then
			self:beh_wait()
		elseif (self.st.behavior == "beh_move" and not self.st.target == "waypoint") then
			self:beh_move()
		elseif (self.st.target == "waypoint") then
			self:beh_path()
		end
	end
end

function action_beh:set_desired_distance()
	local keep_distance = xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.keep_distance)
	self.st.desired_distance	= tonumber(xr_logic.pick_section_from_condlist(db.actor, self.object, self.st[keep_distance.."_desired_dist"]))
end

function action_beh:set_desired_behavior()
	self.st.behavior = xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.behavior_state,"behavior_state")
	--self.st.path_mode	= xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.path_walk_enabled,"path_walk_enabled")
end

function action_beh:set_desired_animation()
	self.st.wait_animation 		= xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.wait_cond)
	self.st.walk_animation 		= xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.walk_cond)
	self.st.jog_animation 		= xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.jog_cond)
	self.st.run_animation 		= xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.run_cond)
	self.st.sprint_animation 	= xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.sprint_cond)
	self.st.delay_animation 	= xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.delay_cond)
end

function action_beh:set_desired_target()
	local target = xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.goto_target)
	self.st.target = target
	if not (target) or (target == "") then
		self.st.desired_target = {}
		return
	end

	local t = {}
	local function set_position_data(id)
		local obj = level.object_by_id(id)
		local sobj = alife():object(id)
		if (obj) then
			t.level_vertex_id = obj:level_vertex_id()
			t.game_vertex_id = obj:game_vertex_id()
			t.position = obj:position()
			t.direction = obj:direction()
			t.object = sobj
		elseif (sobj) then
			t.level_vertex_id = sobj.m_level_vertex_id
			t.game_vertex_id = sobj.m_game_vertex_id
			t.position = sobj.position
			t.direction = self.object:position():sub(t.position)
			t.object = sobj
		end
	end
	local obj = get_story_object(target)
	if (obj) then
		set_position_data(obj:id())
	elseif (target == "waypoint") then
		t = self:get_current_waypoint()
	elseif (target == "commander") then
		local squad = get_object_squad(self.object)
		if not(squad:commander_id() == self.object:id()) then
			set_position_data(squad:commander_id())
		end
	elseif (string.find(target,"lvid:")) then
		local vid,pos
		for s in string.gmatch(target,"lvid:(%d+)") do
			vid = tonumber(s)
		end
		if (vid) then
			t.level_vertex_id = vid
			t.position = level.vertex_position(vid)
			t.direction = self.object:position():sub(t.position)
			t.object = nil
		end
	elseif (string.find(target,"id:")) then
		local id
		for s in string.gmatch(target,"id:(%w+)") do
			id = tonumber(s)
		end
		if (id) then
			set_position_data(id)
		end
	end
	self.st.desired_target = t
end

function action_beh:beh_wait()
	local state = state_mgr.get_state(self.object)
	if (new_state and new_state ~= state) then
		state_mgr.set_state(self.object, new_state,nil, nil, {look_object = nil }, { animation = true })
	end
end

function action_beh:set_state()
	local new_state
	local dist_walk	= tonumber(xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.walk_dist))
	local dist_jog 	= tonumber(xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.jog_dist))
	local dist_run 	= tonumber(xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.run_dist))
	local t = time_global()

	if t >= self.keep_state_until then
		self.keep_state_until = t + keep_state_min_time
		if (self.dist_to_assist_pt <= dist_walk ) then
			new_state = self.st.walk_animation
		elseif (self.dist_to_assist_pt <= dist_jog ) then
			new_state = self.st.jog_animation
		elseif (self.dist_to_assist_pt <= dist_run ) then
			new_state = self.st.run_animation
		else
			new_state = self.st.sprint_animation
		end
	end

	local state = state_mgr.get_state(self.object)
	if (new_state and new_state ~= state) then
		state_mgr.set_state(self.object, new_state,nil, nil, nil, { animation = true })
	end
end

class "position_node"
function position_node:__init(amt)
	self.node = {}
	for i=1,amt do
		self.node[i] = {}
	end
end

function position_node:select_best_vertex_id(object,dir,lvid,distance)
	local closest
	for i=1, #self.node do
		if	(bit_and(i,1)) then
			self.node[i].desired_direction = vector_rotate_y(dir, -math.random(50,60))
		else
			self.node[i].desired_direction = vector_rotate_y(dir, math.random(50,60))
		end

		self.node[i].vertex_id = level.vertex_in_direction(lvid, self.node[i].desired_direction, distance)

		if (self.node[i].vertex_id and object:accessible(self.node[i].vertex_id)) then
			self.node[i].distance = self.node[i].vertex_id == lvid and -1 or object:position():distance_to_sqr(level.vertex_position(self.node[i].vertex_id))

			if not (closest) then
				closest = self.node[i].vertex_id
			end

			if (self.node[i-1] and self.node[i-1].distance < self.node[i].distance) then
				closest = self.node[i-1].vertex_id
			end
		end
	end
	return closest and closest ~= -1 and closest
end

function action_beh:beh_move()
	if not (self.st.desired_target.position) then
		return
	end

	if (self.st.desired_target.object and not simulation_objects.is_on_the_same_level(self.object,self.st.desired_target.object)) then
		local gvid = self.st.desired_target.game_vertex_id or self.st.desired_target.object.m_game_vertex_id
		self.object:set_dest_game_vertex_id(gvid)
	else
		local select_new_pt = false
		local target

		local dist_from_self_to_goto_target = self.object:position():distance_to(self.st.desired_target.position)
		local dist_from_assist_pt_to_goto_target

		if ( self.st.assist_point ) then
			dist_from_assist_pt_to_goto_target = level.vertex_position(self.st.assist_point):distance_to(self.st.desired_target.position)
		end

		if (( dist_from_self_to_goto_target >= self.st.desired_distance ) and
		 (not dist_from_assist_pt_to_goto_target or
			dist_from_assist_pt_to_goto_target >= self.st.desired_distance * 2)) then
			select_new_pt = true
		end

		if ( select_new_pt ) then
			local node = position_node(2)
			self.st.assist_point = node:select_best_vertex_id(self.object,self.st.desired_target.direction,self.st.desired_target.level_vertex_id,self.st.desired_distance)
			if (not self.st.assist_point) then
				return
			end
		elseif not ( self.st.assist_point ) then
			return
		end

		self.object:set_dest_level_vertex_id(self.st.assist_point)
		self.object:set_desired_position(level.vertex_position(self.st.assist_point))
	end
	self.object:set_path_type(game_object.level_path)
	self.object:set_desired_direction()
	self.dist_to_assist_pt = level.vertex_position(self.st.assist_point):distance_to(self.object:position())
	--self.dist_from_self_to_goto_target = dist_from_self_to_goto_target
	self:set_state()
end

function action_beh:beh_path()
	if not (self.st.desired_target.position) then
		return
	end

	local pos = self.object:position()
	pos = vector():set(pos.x,self.st.desired_target.position.y,pos.z)
	local dist = pos:distance_to(self.st.desired_target.position)

	if (dist > 1.2) then
		self.object:set_path_type(game_object.level_path)
		self.object:set_desired_direction()
		self.object:set_dest_level_vertex_id(self.st.desired_target.level_vertex_id)
		self.object:set_desired_position(self.st.desired_target.position)
		self.dist_to_assist_pt = dist
		self:set_state()
		return
	end

	if (not self.st.wait_delay) then
		self.st.wait_delay = time_global() + (self.st.desired_target.delay or 0)
	end

	if (self.st.wait_delay and time_global() > self.st.wait_delay) then
		self:increment_waypoint_index()
		self.st.wait_delay = nil
	else
		local state = state_mgr.get_state(self.object)
		local new_state = self.st.desired_target.delay_animation or self.st.delay_animation
		if (new_state and new_state ~= state) then
			state_mgr.set_state(self.object, new_state,nil, nil,{look_object = self.st.desired_target.look_object, look_position = self.st.desired_target.look_position }, { animation = true})
		end
	end
end

function angle_dir(ang)
	return vector():setHP(ang.y,ang.x):normalize()
end

function action_beh:get_current_waypoint()
	local st = db.storage[self.object:id()]
	local str = alun_utils.read_from_ini(st.ini,st.active_section,"pt"..self.st.path_index,"string",nil)
	if not (str) then
		return {}
	end

	local t = {}
	for s in string.gmatch(str,"look:([-]?%d+[.]?%d*,[-]?%d+[.]?%d*,[-]?%d+[.]?%d*)") do
		local p = alun_utils.str_explode(s,",")
		t.look_position = vector():set(tonumber(p[1]),tonumber(p[2]),tonumber(p[3]))
	end

	for s in string.gmatch(str,"look_object:(.%S+)") do
		t.look_object = s
	end

	for s in string.gmatch(str,"snap:([-]?%d+[.]?%d*,[-]?%d+[.]?%d*,[-]?%d+[.]?%d*)") do
		local p = alun_utils.str_explode(s,",")
		t.snap_pos = p
	end

	local a = string.find(str,"look")
	if (a) then
		str = string.sub(str,1,a-1)
	end

	a = string.find(str,"snap")
	if (a) then
		str = string.sub(str,1,a-1)
	end

	local pt = alun_utils.str_explode(str,",")

	t.level_vertex_id = tonumber(pt[1])
	t.position = level.vertex_position(t.level_vertex_id)
	t.direction = self.object:position():sub(t.position)
	t.delay = pt[2] and tonumber(pt[2]) or 0
	t.delay_animation = pt[3]
	return t
end

function action_beh:increment_waypoint_index()
	local st = db.storage[self.object:id()]
	if (not self.st.path_reverse and not alun_utils.read_from_ini(st.ini,st.active_section,"pt"..self.st.path_index+1,"string",nil)) then
		local new_section = xr_logic.pick_section_from_condlist(db.actor, self.object, self.st.path_end)
		--alun_utils.printf("path_end = %s [%s]",new_section,self.st.path_end)
		if (new_section and new_section ~= "nil") then
			if (new_section == "reverse") then
				self.st.path_reverse = true
			elseif (new_section ~= "loop") then
				xr_logic.switch_to_section(self.object, db.storage[self.object:id()].ini, new_section)
				alun_utils.save_var(self.object,"path_index",nil)
				return
			else
				self.st.path_index = 1
			end
		end
	elseif (self.st.path_index == 1 and self.st.path_reverse) then
		self.st.path_reverse = nil
		self.st.path_index = 1
	else
		self.st.path_index = self.st.path_reverse and self.st.path_index - 1 or self.st.path_index + 1
	end
	alun_utils.save_var(self.object,"path_index",self.st.path_index)
end

function action_beh:finalize()
	action_base.finalize(self)
end

--
-------------------------- Scheme Handlers ------------------------------------------------------------

beh_evid =  188111
beh_actid = 188111

function add_to_binder(npc, ini, scheme, section, storage)
	local manager = npc:motivation_action_manager()
	-- evaluators
	manager:add_evaluator(beh_evid, this.evaluator_beh(storage, "evaluator_beh"))

	local new_action = this.action_beh(npc, "action_beh", storage)
	new_action:add_precondition(world_property(stalker_ids.property_anomaly,false))
	new_action:add_precondition(world_property(stalker_ids.property_alive, true))
	new_action:add_precondition(world_property(stalker_ids.property_enemy, false))
	new_action:add_precondition(world_property(beh_evid, true))
	--new_action:add_precondition(world_property(xr_gather_items.evaid,false))
	--new_action:add_precondition(world_property(xr_evaluators_id.corpse_exist,false))
	new_action:add_precondition(world_property(stalker_ids.property_danger,false))
	--new_action:add_precondition(world_property(stalker_ids.property_danger_grenade, false))

	xr_motivator.addCommonPrecondition(new_action)

	new_action:add_effect(world_property(beh_evid, false))
	new_action:add_effect(world_property(xr_evaluators_id.state_mgr + 4, false))
	manager:add_action(beh_actid, new_action)

	xr_logic.subscribe_action_for_events(npc, storage, new_action)

	new_action = manager:action(xr_actions_id.alife)
	new_action:add_precondition(world_property(beh_evid, false))
end

function disable_scheme(npc,scheme)
	local st = db.storage[npc:id()][scheme]
	if st then
		st.enabled = false
	end
end

function add_common_precondition(action)
	--action:add_precondition(world_property(beh_evid, false))
end

function set_scheme(npc,ini,scheme,section)
	local st = xr_logic.assign_storage_and_bind(npc,ini,"beh",section)
	st.logic = xr_logic.cfg_get_switch_conditions(ini, section, npc)
	init_custom_data(npc, ini, section, st, "beh")
end

function reset_scheme(npc,scheme,section,st)
end

------------------- CUSTOM DATA LOGIC ------------------------------------------
function init_custom_data(npc, ini, section, st, scheme)
	local def = {}

	def.path_walk_enabled= "false"

	def.behavior_state 	= "{+npcx_beh_wait} beh_wait, {+npcx_beh_patrol_mode !is_squad_commander} beh_move, {+npcx_beh_patrol_mode} beh_patrol, beh_move"
	def.goto_target 	= "{!is_squad_commander} commander, actor"

	def.walk_dist 		= "{+npcx_beh_patrol_mode} 90, 5"
	def.jog_dist 		= "{+npcx_beh_patrol_mode} 150, 10"
	def.run_dist 		= "{+npcx_beh_patrol_mode} 250, {-npcx_beh_patrol_mode +npcx_beh_substate_stealth} 40, 30"

	def.keep_distance 	= "{+npcx_beh_distance_far} far, near"

	def.near_desired_dist 	= "{+npcx_beh_patrol_mode =is_squad_commander} 1, {!is_squad_commander} 2, 3"
	def.far_desired_dist	= "{+npcx_beh_patrol_mode =is_squad_commander} 1, {!is_squad_commander} 2, 8"

	def.wait_cond 	= "{=is_wounded} nil, {+npcx_beh_substate_stealth} hide, guard"
	def.walk_cond 	= "{=is_wounded} nil, {+npcx_beh_patrol_mode -npcx_beh_substate_stealth} patrol,{+npcx_beh_substate_stealth} sneak, patrol"
	def.jog_cond 	= "{=is_wounded} nil, {+npcx_beh_substate_stealth} sneak_run, rush"
	def.run_cond 	= "{=is_wounded} nil, {+npcx_beh_substate_stealth} rush, assault"
	def.sprint_cond = "{=is_wounded} nil, {+npcx_beh_substate_stealth} sprint, sprint"
	def.delay_cond	= "{=is_wounded} nil, {+npcx_beh_substate_stealth} hide, random_animation"

	st.path_walk_enabled= xr_logic.parse_condlist(npc, section, "path_mode", 		utils.cfg_get_string(ini, section, "path_mode", npc, false, "", 	def.path_walk_enabled ))

	st.behavior_state 	= xr_logic.parse_condlist(npc, section, "behavior_state",		utils.cfg_get_string(ini, section, "behavior_state", npc, false, "", 	def.behavior_state))
	st.goto_target		= xr_logic.parse_condlist(npc, section, "goto_target", 			utils.cfg_get_string(ini, section, "goto_target", npc, false, "", 	def.goto_target))

	st.walk_dist 		= xr_logic.parse_condlist(npc, section, "walk_dist", 			utils.cfg_get_string(ini, section, "walk_dist", npc, false, "", 	def.walk_dist))
	st.jog_dist 		= xr_logic.parse_condlist(npc, section, "jog_dist", 			utils.cfg_get_string(ini, section, "jog_dist", npc, false, "", 	def.jog_dist))
	st.run_dist 		= xr_logic.parse_condlist(npc, section, "run_dist", 			utils.cfg_get_string(ini, section, "run_dist", npc, false, "", 	def.run_dist))

	st.keep_distance	= xr_logic.parse_condlist(npc, section, "keep_distance", 		utils.cfg_get_string(ini, section, "keep_distance", npc, false, "", 	def.keep_distance))

	st.near_desired_dist= xr_logic.parse_condlist(npc, section, "near_desired_dist", 	utils.cfg_get_string(ini, section, "near_desired_dist", npc, false, "", 	def.near_desired_dist))
	st.far_desired_dist = xr_logic.parse_condlist(npc, section, "far_desired_dist", 	utils.cfg_get_string(ini, section, "far_desired_dist", npc, false, "", 	def.far_desired_dist))

	st.wait_cond 		= xr_logic.parse_condlist(npc, section, "wait_anim", 	utils.cfg_get_string(ini, section, "wait_anim", npc, false, "", 	def.wait_cond))
	st.walk_cond 		= xr_logic.parse_condlist(npc, section, "walk_anim", 	utils.cfg_get_string(ini, section, "walk_anim", npc, false, "", 	def.walk_cond))
	st.jog_cond 		= xr_logic.parse_condlist(npc, section, "jog_anim",	 	utils.cfg_get_string(ini, section, "jog_anim", npc, false, "", 	def.jog_cond))
	st.run_cond			= xr_logic.parse_condlist(npc, section, "run_anim", 	utils.cfg_get_string(ini, section, "run_anim", npc, false, "", 	def.run_cond))
	st.sprint_cond 		= xr_logic.parse_condlist(npc, section, "sprint_anim", 	utils.cfg_get_string(ini, section, "sprint_anim", npc, false, "", def.sprint_cond))
	st.delay_cond 		= xr_logic.parse_condlist(npc, section, "delay_anim", 	utils.cfg_get_string(ini, section, "delay_anim", npc, false, "", def.delay_cond))

	st.path_end 		= xr_logic.parse_condlist(npc, section, "path_end", 	utils.cfg_get_string(ini, section, "path_end", npc, false, "", "nil" ))

	-- Grab waypoints unless they exist
	if (st.pathpoint and next(st.pathpoint) ) then
		return
	end

	st.pathpoint = {}
	st.path_index = alun_utils.load_var(npc,"path_index",1)
	-- Grab pathpoints


	local t = {}
	local str
	local pt

	local i = 1
--[[
	while ini:line_exist(sec,"pt"..tostring(i)) do
		str = alun_utils.read_from_ini(ini,sec,"pt"..tostring(i),"string",nil)
		i = i + 1
		if not (str) then
			return
		end

		pt = alun_utils.str_explode(str,",")

		t.level_vertex_id = tonumber(pt[1])
		t.position = level.vertex_position(t.level_vertex_id)
		t.direction = pt[4] and vector():set(0,tonumber(pt[4]),0) or npc:position():sub(t.position)
		t.delay = pt[2] and tonumber(pt[2]) or 0
		t.delay_animation = pt[3]

		table.insert(st.pathpoint, t)
	end

	while alun_utils.load_var(npc,"pathpoint"..tostring(i)) do
		str = alun_utils.load_var(npc,"pathpoint"..tostring(i))
		if not (str) then
			i = i + 1
			return
		end

		for s in string.gmatch(str,"pos:([-]?%d+[.]?%d*,[-]?%d+[.]?%d*,[-]?%d+[.]?%d*)") do
			local p = alun_utils.str_explode(s,",")
			t.position = vector():set(tonumber(p[1]),tonumber(p[2]),tonumber(p[3]))
		end

		for s in string.gmatch(str,"dir:([-]?%d+[.]?%d*,[-]?%d+[.]?%d*,[-]?%d+[.]?%d*)") do
			local p = alun_utils.str_explode(s,",")
			t.direction = vector():set(tonumber(p[1]),tonumber(p[2]),tonumber(p[3]))
		end

		for s in string.gmatch(str,"lvid:(%w+)") do
			t.level_vertex_id = tonumber(s)
		end

		table.insert(st.pathpoint, t)
		i = i + 1
	end
--]]
end
